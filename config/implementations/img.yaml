# C++ Implementation Snippets
# Referenced by inline_impl field in mapping YAML files

# Each implementation is a complete function definition
# Generator will inject only the needed implementations into output C++

img_resize: |
  inline Image resize(const Image& src, int new_height, int new_width) {
      Image dst(new_height, new_width, src.channels);
      float scale_y = static_cast<float>(src.height) / new_height;
      float scale_x = static_cast<float>(src.width) / new_width;

      for (int y = 0; y < new_height; ++y) {
          for (int x = 0; x < new_width; ++x) {
              float src_y = (y + 0.5f) * scale_y - 0.5f;
              float src_x = (x + 0.5f) * scale_x - 0.5f;

              src_y = std::max(0.0f, std::min(src_y, src.height - 1.0f));
              src_x = std::max(0.0f, std::min(src_x, src.width - 1.0f));

              int y0 = static_cast<int>(src_y);
              int x0 = static_cast<int>(src_x);
              int y1 = std::min(y0 + 1, src.height - 1);
              int x1 = std::min(x0 + 1, src.width - 1);

              float dy = src_y - y0;
              float dx = src_x - x0;

              for (int c = 0; c < src.channels; ++c) {
                  float v00 = src.at(y0, x0, c);
                  float v01 = src.at(y0, x1, c);
                  float v10 = src.at(y1, x0, c);
                  float v11 = src.at(y1, x1, c);

                  float interpolated = v00 * (1 - dx) * (1 - dy) +
                                     v01 * dx * (1 - dy) +
                                     v10 * (1 - dx) * dy +
                                     v11 * dx * dy;

                  dst.at(y, x, c) = static_cast<uint8_t>(interpolated + 0.5f);
              }
          }
      }

      return dst;
  }

img_imread: |
  inline Image imread(const std::string& path, int mode = 1) {
      int width, height, channels_in_file;
      unsigned char* stb_data = stbi_load(path.c_str(), &width, &height, &channels_in_file, 0);

      if (!stb_data) {
          throw std::runtime_error("Failed to load image: " + path);
      }

      int channels = channels_in_file;
      Image img(height, width, channels);

      // Convert to BGR (to match OpenCV)
      for (int y = 0; y < height; ++y) {
          for (int x = 0; x < width; ++x) {
              if (channels == 3) {
                  size_t idx = (y * width + x) * 3;
                  img.at(y, x, 0) = stb_data[idx + 2];  // B
                  img.at(y, x, 1) = stb_data[idx + 1];  // G
                  img.at(y, x, 2) = stb_data[idx + 0];  // R
              } else if (channels == 4) {
                  size_t idx = (y * width + x) * 4;
                  img.at(y, x, 0) = stb_data[idx + 2];  // B
                  img.at(y, x, 1) = stb_data[idx + 1];  // G
                  img.at(y, x, 2) = stb_data[idx + 0];  // R
                  img.at(y, x, 3) = stb_data[idx + 3];  // A
              } else {
                  size_t idx = y * width + x;
                  img.at(y, x, 0) = stb_data[idx];
              }
          }
      }

      stbi_image_free(stb_data);

      // Convert to grayscale if mode == 0
      if (mode == 0 && img.channels == 3) {
          Image gray(img.height, img.width, 1);
          for (int y = 0; y < img.height; ++y) {
              for (int x = 0; x < img.width; ++x) {
                  uint8_t b = img.at(y, x, 0);
                  uint8_t g = img.at(y, x, 1);
                  uint8_t r = img.at(y, x, 2);
                  gray.at(y, x, 0) = static_cast<uint8_t>(0.114 * b + 0.587 * g + 0.299 * r);
              }
          }
          return gray;
      }

      return img;
  }

img_cvt_color_bgr2rgb: |
  inline Image cvtColor_BGR2RGB(const Image& src) {
      Image dst = src;
      if (src.channels == 3) {
          for (int y = 0; y < src.height; ++y) {
              for (int x = 0; x < src.width; ++x) {
                  std::swap(dst.at(y, x, 0), dst.at(y, x, 2));
              }
          }
      }
      return dst;
  }

img_astype_float32: |
  inline ImageF astype_float32(const Image& img) {
      return ImageF(img);
  }

img_operator_div: |
  inline ImageF operator/(const Image& img, float scalar) {
      ImageF result(img);
      for (auto& val : result.data) {
          val /= scalar;
      }
      return result;
  }

img_reshape: |
  inline ImageF reshape(const ImageF& img, int new_height, int new_width) {
      int total_elements = img.height * img.width * img.channels;
      int expected_elements = new_height * new_width;

      if (total_elements != expected_elements) {
          throw std::runtime_error("Cannot reshape: element count mismatch");
      }

      ImageF result(new_height, new_width, 1);
      result.data = img.data;
      return result;
  }
