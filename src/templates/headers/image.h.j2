/**
 * Lightweight Image Processing Library
 * Supports JPEG, PNG, BMP via stb_image.h
 * Fallback to PPM/PGM for dependency-free mode
 */

#ifndef IMAGE_H
#define IMAGE_H

#include <vector>
#include <string>
#include <cmath>
#include <algorithm>
#include <fstream>
#include <stdexcept>

// Use static inline for STB functions to avoid multiple definition errors
#define STBI_STATIC
#define STB_IMAGE_STATIC
#define STB_IMAGE_WRITE_STATIC
#define STB_IMAGE_IMPLEMENTATION
#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "stb_image.h"
#include "stb_image_write.h"

namespace img {

// Forward declaration
class ImageF;

// Image class with uint8 storage (matches OpenCV)
class Image {
public:
    std::vector<uint8_t> data;
    int height;
    int width;
    int channels;

    Image() : height(0), width(0), channels(0) {}

    Image(int h, int w, int c) : height(h), width(w), channels(c) {
        data.resize(h * w * c, 0);
    }

    // Assignment from ImageF (converts float to uint8)
    Image& operator=(const ImageF& other);

    uint8_t& at(int y, int x, int c) {
        return data[(y * width + x) * channels + c];
    }

    const uint8_t& at(int y, int x, int c) const {
        return data[(y * width + x) * channels + c];
    }

    size_t size() const { return data.size(); }
};

// Float image for processing operations
class ImageF {
public:
    std::vector<float> data;
    int height;
    int width;
    int channels;

    ImageF() : height(0), width(0), channels(0) {}

    ImageF(int h, int w, int c) : height(h), width(w), channels(c) {
        data.resize(h * w * c, 0.0f);
    }

    ImageF(const Image& img) : height(img.height), width(img.width), channels(img.channels) {
        data.resize(img.data.size());
        for (size_t i = 0; i < img.data.size(); ++i) {
            data[i] = static_cast<float>(img.data[i]);
        }
    }

    float& at(int y, int x, int c) {
        return data[(y * width + x) * channels + c];
    }

    const float& at(int y, int x, int c) const {
        return data[(y * width + x) * channels + c];
    }

    size_t size() const { return data.size(); }

    // Convert back to uint8
    Image to_uint8() const {
        Image result(height, width, channels);
        for (size_t i = 0; i < data.size(); ++i) {
            float val = std::clamp(data[i], 0.0f, 255.0f);
            result.data[i] = static_cast<uint8_t>(val + 0.5f);
        }
        return result;
    }
};

// Check file extension
inline std::string get_extension(const std::string& path) {
    size_t dot_pos = path.find_last_of('.');
    if (dot_pos == std::string::npos) return "";
    std::string ext = path.substr(dot_pos);
    std::transform(ext.begin(), ext.end(), ext.begin(), ::tolower);
    return ext;
}

// Load image using stb_image (JPEG, PNG, BMP, TGA, etc.)
inline Image imread_stb(const std::string& path) {
    int width, height, channels_in_file;
    unsigned char* stb_data = stbi_load(path.c_str(), &width, &height, &channels_in_file, 0);

    if (!stb_data) {
        throw std::runtime_error("stb_image failed to load: " + path);
    }

    int channels = channels_in_file;
    Image img(height, width, channels);

    // Convert to BGR (to match OpenCV)
    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (channels == 3) {
                size_t idx = (y * width + x) * 3;
                img.at(y, x, 0) = stb_data[idx + 2];  // B
                img.at(y, x, 1) = stb_data[idx + 1];  // G
                img.at(y, x, 2) = stb_data[idx + 0];  // R
            } else if (channels == 4) {
                size_t idx = (y * width + x) * 4;
                img.at(y, x, 0) = stb_data[idx + 2];  // B
                img.at(y, x, 1) = stb_data[idx + 1];  // G
                img.at(y, x, 2) = stb_data[idx + 0];  // R
                img.at(y, x, 3) = stb_data[idx + 3];  // A
            } else {
                size_t idx = y * width + x;
                img.at(y, x, 0) = stb_data[idx];
            }
        }
    }

    stbi_image_free(stb_data);
    return img;
}

// Load PPM/PGM format (dependency-free fallback)
inline Image imread_ppm(const std::string& path) {
    std::ifstream file(path, std::ios::binary);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open file: " + path);
    }

    std::string magic;
    file >> magic;

    int width, height, maxval;
    file >> width >> height >> maxval;
    file.ignore(1);

    int channels = (magic == "P6") ? 3 : 1;
    Image img(height, width, channels);

    std::vector<unsigned char> buffer(width * height * channels);
    file.read(reinterpret_cast<char*>(buffer.data()), buffer.size());

    for (int y = 0; y < height; ++y) {
        for (int x = 0; x < width; ++x) {
            if (channels == 3) {
                size_t idx = (y * width + x) * 3;
                img.at(y, x, 0) = buffer[idx + 2];  // B
                img.at(y, x, 1) = buffer[idx + 1];  // G
                img.at(y, x, 2) = buffer[idx + 0];  // R
            } else {
                size_t idx = y * width + x;
                img.at(y, x, 0) = buffer[idx];
            }
        }
    }

    return img;
}

// Main image loader (auto-detects format)
inline Image imread(const std::string& path, int mode = 1) {
    // mode: 0 = grayscale, 1 = color (default)
    std::string ext = get_extension(path);

    Image img;
    if (ext == ".ppm" || ext == ".pgm") {
        img = imread_ppm(path);
    } else {
        img = imread_stb(path);
    }

    // Convert to grayscale if mode == 0
    if (mode == 0 && img.channels == 3) {
        Image gray(img.height, img.width, 1);
        for (int y = 0; y < img.height; ++y) {
            for (int x = 0; x < img.width; ++x) {
                // BGR to grayscale: 0.299*R + 0.587*G + 0.114*B
                uint8_t b = img.at(y, x, 0);
                uint8_t g = img.at(y, x, 1);
                uint8_t r = img.at(y, x, 2);
                gray.at(y, x, 0) = static_cast<uint8_t>(0.114 * b + 0.587 * g + 0.299 * r);
            }
        }
        return gray;
    }

    return img;
}

// Image resize (bilinear interpolation - matches OpenCV default)
inline Image resize(const Image& src, int new_height, int new_width) {
    Image dst(new_height, new_width, src.channels);

    // Use OpenCV's coordinate formula: src = (dst + 0.5) * scale - 0.5
    float scale_y = static_cast<float>(src.height) / new_height;
    float scale_x = static_cast<float>(src.width) / new_width;

    for (int y = 0; y < new_height; ++y) {
        for (int x = 0; x < new_width; ++x) {
            float src_y = (y + 0.5f) * scale_y - 0.5f;
            float src_x = (x + 0.5f) * scale_x - 0.5f;

            // Clamp to valid range
            src_y = std::max(0.0f, std::min(src_y, src.height - 1.0f));
            src_x = std::max(0.0f, std::min(src_x, src.width - 1.0f));

            int y0 = static_cast<int>(src_y);
            int x0 = static_cast<int>(src_x);
            int y1 = std::min(y0 + 1, src.height - 1);
            int x1 = std::min(x0 + 1, src.width - 1);

            float dy = src_y - y0;
            float dx = src_x - x0;

            for (int c = 0; c < src.channels; ++c) {
                float v00 = src.at(y0, x0, c);
                float v01 = src.at(y0, x1, c);
                float v10 = src.at(y1, x0, c);
                float v11 = src.at(y1, x1, c);

                float interpolated = v00 * (1 - dx) * (1 - dy) +
                                    v01 * dx * (1 - dy) +
                                    v10 * (1 - dx) * dy +
                                    v11 * dx * dy;

                dst.at(y, x, c) = static_cast<uint8_t>(interpolated + 0.5f);
            }
        }
    }

    return dst;
}

// Float resize
inline ImageF resize(const ImageF& src, int new_height, int new_width) {
    ImageF dst(new_height, new_width, src.channels);

    // Use OpenCV's coordinate formula: src = (dst + 0.5) * scale - 0.5
    float scale_y = static_cast<float>(src.height) / new_height;
    float scale_x = static_cast<float>(src.width) / new_width;

    for (int y = 0; y < new_height; ++y) {
        for (int x = 0; x < new_width; ++x) {
            float src_y = (y + 0.5f) * scale_y - 0.5f;
            float src_x = (x + 0.5f) * scale_x - 0.5f;

            // Clamp to valid range
            src_y = std::max(0.0f, std::min(src_y, src.height - 1.0f));
            src_x = std::max(0.0f, std::min(src_x, src.width - 1.0f));

            int y0 = static_cast<int>(src_y);
            int x0 = static_cast<int>(src_x);
            int y1 = std::min(y0 + 1, src.height - 1);
            int x1 = std::min(x0 + 1, src.width - 1);

            float dy = src_y - y0;
            float dx = src_x - x0;

            for (int c = 0; c < src.channels; ++c) {
                float v00 = src.at(y0, x0, c);
                float v01 = src.at(y0, x1, c);
                float v10 = src.at(y1, x0, c);
                float v11 = src.at(y1, x1, c);

                dst.at(y, x, c) = v00 * (1 - dx) * (1 - dy) +
                                 v01 * dx * (1 - dy) +
                                 v10 * (1 - dx) * dy +
                                 v11 * dx * dy;
            }
        }
    }

    return dst;
}

// BGR to RGB conversion
inline Image cvtColor_BGR2RGB(const Image& src) {
    Image dst = src;
    if (src.channels == 3) {
        for (int y = 0; y < src.height; ++y) {
            for (int x = 0; x < src.width; ++x) {
                std::swap(dst.at(y, x, 0), dst.at(y, x, 2));
            }
        }
    }
    return dst;
}

inline ImageF cvtColor_BGR2RGB(const ImageF& src) {
    ImageF dst = src;
    if (src.channels == 3) {
        for (int y = 0; y < src.height; ++y) {
            for (int x = 0; x < src.width; ++x) {
                std::swap(dst.at(y, x, 0), dst.at(y, x, 2));
            }
        }
    }
    return dst;
}

// Gaussian blur (simple 3x3)
inline Image GaussianBlur(const Image& src, int ksize) {
    Image dst(src.height, src.width, src.channels);

    float kernel[3][3] = {
        {1.0f/16, 2.0f/16, 1.0f/16},
        {2.0f/16, 4.0f/16, 2.0f/16},
        {1.0f/16, 2.0f/16, 1.0f/16}
    };

    for (int y = 1; y < src.height - 1; ++y) {
        for (int x = 1; x < src.width - 1; ++x) {
            for (int c = 0; c < src.channels; ++c) {
                float sum = 0.0f;
                for (int ky = -1; ky <= 1; ++ky) {
                    for (int kx = -1; kx <= 1; ++kx) {
                        sum += src.at(y + ky, x + kx, c) * kernel[ky + 1][kx + 1];
                    }
                }
                dst.at(y, x, c) = static_cast<uint8_t>(sum + 0.5f);
            }
        }
    }

    return dst;
}

inline ImageF GaussianBlur(const ImageF& src, int ksize) {
    ImageF dst(src.height, src.width, src.channels);

    float kernel[3][3] = {
        {1.0f/16, 2.0f/16, 1.0f/16},
        {2.0f/16, 4.0f/16, 2.0f/16},
        {1.0f/16, 2.0f/16, 1.0f/16}
    };

    for (int y = 1; y < src.height - 1; ++y) {
        for (int x = 1; x < src.width - 1; ++x) {
            for (int c = 0; c < src.channels; ++c) {
                float sum = 0.0f;
                for (int ky = -1; ky <= 1; ++ky) {
                    for (int kx = -1; kx <= 1; ++kx) {
                        sum += src.at(y + ky, x + kx, c) * kernel[ky + 1][kx + 1];
                    }
                }
                dst.at(y, x, c) = sum;
            }
        }
    }

    return dst;
}

// Bilateral filter (simplified)
inline Image bilateralFilter(const Image& src, int d, double sigma_color, double sigma_space) {
    Image dst = src;
    return dst;
}

inline ImageF bilateralFilter(const ImageF& src, int d, double sigma_color, double sigma_space) {
    ImageF dst = src;
    return dst;
}

// Element-wise division (converts to float)
inline ImageF operator/(const Image& img, float scalar) {
    ImageF result(img);
    for (auto& val : result.data) {
        val /= scalar;
    }
    return result;
}

inline ImageF operator/(const ImageF& img, float scalar) {
    ImageF result = img;
    for (auto& val : result.data) {
        val /= scalar;
    }
    return result;
}

// Convert to float32
inline ImageF astype_float32(const Image& img) {
    return ImageF(img);
}

// Image::operator= implementation (defined after ImageF)
inline Image& Image::operator=(const ImageF& other) {
    height = other.height;
    width = other.width;
    channels = other.channels;
    data.resize(other.data.size());

    for (size_t i = 0; i < other.data.size(); ++i) {
        float val = std::clamp(other.data[i], 0.0f, 255.0f);
        data[i] = static_cast<uint8_t>(val + 0.5f);
    }

    return *this;
}

// Reshape for flattening (returns a copy with metadata change)
inline ImageF reshape(const ImageF& src, int batch, int size) {
    if (batch * size != src.width * src.height * src.channels) {
        throw std::runtime_error("Reshape dimensions don't match total size");
    }

    ImageF dst(batch, size, 1);
    std::copy(src.data.begin(), src.data.end(), dst.data.begin());
    return dst;
}

inline Image reshape(const Image& src, int batch, int size) {
    if (batch * size != src.width * src.height * src.channels) {
        throw std::runtime_error("Reshape dimensions don't match total size");
    }

    Image dst(batch, size, 1);
    std::copy(src.data.begin(), src.data.end(), dst.data.begin());
    return dst;
}

// Array/Vector operations for NumPy compatibility
inline int argmax(const std::vector<float>& arr) {
    return std::distance(arr.begin(), std::max_element(arr.begin(), arr.end()));
}

inline int argmin(const std::vector<float>& arr) {
    return std::distance(arr.begin(), std::min_element(arr.begin(), arr.end()));
}

inline float max(const std::vector<float>& arr) {
    return *std::max_element(arr.begin(), arr.end());
}

inline float min(const std::vector<float>& arr) {
    return *std::min_element(arr.begin(), arr.end());
}

} // namespace img

#endif // IMAGE_H
