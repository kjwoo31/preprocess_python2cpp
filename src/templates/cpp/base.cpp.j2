// Auto-generated C++ code from Python preprocessing pipeline
// Generated by Python-to-C++ Porting Agent
// Pipeline: {{ pipeline.name }}
// No external dependencies required

#include <iostream>
#include <string>
#include <vector>
#include <cmath>
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <sstream>

// Lightweight image processing library (header-only)
#include "image.h"

namespace fs = std::filesystem;
using img::Image;
using img::ImageF;

// Type definitions
{% for input in pipeline.inputs %}
// Input: {{ input.name }} - {{ input.type_hint }}
{% endfor %}

/**
 * {{ pipeline.name }}
 *
 * Auto-generated function equivalent to Python preprocessing pipeline.
 *
{% for input in pipeline.inputs %}
 * @param {{ input.name }} {{ input.type_hint }}
{% endfor %}
{% for output in pipeline.outputs %}
 * @return {{ output.type_hint }}
{% endfor %}
 */
{% if pipeline.outputs|length == 1 %}
auto {{ pipeline.name }}(
{%- for input in pipeline.inputs -%}
{%- if loop.index0 > 0 %}, {% endif %}const {{ input.type_hint.base_type|cpp_type }}& {{ input.name }}
{%- endfor -%}
) {
{% else %}
std::tuple<{% for output in pipeline.outputs %}{{ output.type_hint.base_type|cpp_type }}{% if not loop.last %}, {% endif %}{% endfor %}> {{ pipeline.name }}(
{%- for input in pipeline.inputs -%}
{%- if loop.index0 > 0 %}, {% endif %}const {{ input.type_hint.base_type|cpp_type }}& {{ input.name }}
{%- endfor -%}
) {
{% endif %}

    // Operations
{% set declared_vars = [] %}
{% set final_vars = [] %}
{% for op in pipeline.operations %}
    // {{ op.id }}: {{ op.op_type.value }}
{% if op.id in llm_generated_code %}
    // LLM-generated code
    {{ llm_generated_code[op.id] }}
{% elif op.op_type.value == 'function_call' %}
{% if op.function == 'resize' and op.args|length >= 2 %}
    // Special handling for resize with tuple argument
{% if op.output in declared_vars %}
    {{ op.output }} = img::resize({{ op.args[0] }}, {{ op.args[1]|replace('(', '')|replace(')', '')|replace(',', ', ') }});
{% else %}
    auto {{ op.output }} = img::resize({{ op.args[0] }}, {{ op.args[1]|replace('(', '')|replace(')', '')|replace(',', ', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% else %}
{% if op.output in declared_vars %}
    {{ op.output }} = img::{{ op.function }}({{ op.args|join(', ') }});
{% else %}
    auto {{ op.output }} = img::{{ op.function }}({{ op.args|join(', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% endif %}
{% elif op.op_type.value == 'method_call' %}
{% if op.output in declared_vars %}
    {{ op.output }} = img::{{ op.function }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% else %}
    auto {{ op.output }} = img::{{ op.function }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'arithmetic' %}
{% if op.output in declared_vars %}
    {# Variable redeclaration with potential type change - use unique name #}
    auto {{ op.output }}_final = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = final_vars.append(op.output) %}
{% else %}
    auto {{ op.output }} = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'assignment' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ op.args[0] }};
{% else %}
    auto {{ op.output }} = {{ op.args[0] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% endif %}

{% endfor %}

    // Return
{% if pipeline.outputs|length == 1 %}
{% set output_name = pipeline.outputs[0].name %}
{% if output_name in final_vars %}
    return {{ output_name }}_final;
{% else %}
    return {{ output_name }};
{% endif %}
{% else %}
    return std::make_tuple({% for output in pipeline.outputs %}{% if output.name in final_vars %}{{ output.name }}_final{% else %}{{ output.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
{% endif %}
}

// Helper function to save results for validation (uint8)
void save_result(const Image& result, const std::string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    std::string full_path = (results_dir / output_path).string();
    std::ofstream file(full_path, std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    std::ostringstream header;
    header << "{'descr': '|u1', 'fortran_order': False, 'shape': (";
    header << result.height << ", " << result.width;
    if (result.channels > 1) {
        header << ", " << result.channels;
    }
    header << "), }";

    std::string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += std::string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write uint8 data
    file.write(reinterpret_cast<const char*>(result.data.data()), result.data.size());
    file.close();
}

// Helper function to save results for validation (float32)
void save_result(const ImageF& result, const std::string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    std::string full_path = (results_dir / output_path).string();
    std::ofstream file(full_path, std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    std::ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (";
    header << result.height << ", " << result.width;
    if (result.channels > 1) {
        header << ", " << result.channels;
    }
    header << "), }";

    std::string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += std::string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write float32 data
    file.write(reinterpret_cast<const char*>(result.data.data()),
               result.data.size() * sizeof(float));
    file.close();
}

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <input_path>" << std::endl;
        return 1;
    }

    try {
        // Example usage
        std::string input_path = argv[1];

        auto result = {{ pipeline.name }}(input_path);

        // Save result for validation
        save_result(result, "{{ pipeline.name }}_cpp.npy");

        std::cout << "Processing completed successfully" << std::endl;

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
