// Auto-generated Pipeline Orchestrator
// Generated by Python-to-C++ Porting Agent

#include <iostream>
#include <string>
#include <vector>
#include <chrono>
#include <fstream>
#include <sstream>
#include <filesystem>

{% if has_preprocess %}
#include "preprocess.h"
{% endif %}
{% if has_inference %}
#include "inference.h"
{% endif %}
{% if has_postprocess %}
#include "postprocess.h"
{% endif %}

#include "image.h"

using namespace std;
using img::Image;
using img::ImageF;
namespace fs = std::filesystem;

// Save int result to .npy file
void save_result(int result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '<i4', 'fortran_order': False, 'shape': (), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write int32 data
    int32_t value = static_cast<int32_t>(result);
    file.write(reinterpret_cast<const char*>(&value), sizeof(int32_t));
    file.close();
}

// Save float result to .npy file
void save_result(float result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write float32 data
    file.write(reinterpret_cast<const char*>(&result), sizeof(float));
    file.close();
}

// Save tuple result to .npy file
void save_result(const std::tuple<int, float>& result, const string& output_path) {
    save_result(std::get<0>(result), output_path.substr(0, output_path.find(".npy")) + "_0.npy");
    save_result(std::get<1>(result), output_path.substr(0, output_path.find(".npy")) + "_1.npy");
}

// Save string result to .npy file
void save_result(const string& result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header for string
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '<U" << result.length() << "', 'fortran_order': False, 'shape': (), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write string data (UTF-32LE encoding for numpy unicode)
    for (char c : result) {
        uint32_t code = static_cast<uint32_t>(c);
        file.write(reinterpret_cast<const char*>(&code), sizeof(uint32_t));
    }
    file.close();
}

// Save Image result to .npy file
void save_result(const Image& result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '|u1', 'fortran_order': False, 'shape': (";
    header << result.height << ", " << result.width;
    if (result.channels > 1) {
        header << ", " << result.channels;
    }
    header << "), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write uint8 data
    file.write(reinterpret_cast<const char*>(result.data.data()), result.data.size());
    file.close();
}

// Save ImageF result to .npy file
void save_result(const ImageF& result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (";
    header << result.height << ", " << result.width;
    if (result.channels > 1) {
        header << ", " << result.channels;
    }
    header << "), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write float32 data
    file.write(reinterpret_cast<const char*>(result.data.data()),
               result.data.size() * sizeof(float));
    file.close();
}

// Save vector<float> result to .npy file
void save_result(const vector<float>& result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (" << result.size() << ",), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write float32 data
    file.write(reinterpret_cast<const char*>(result.data()),
               result.size() * sizeof(float));
    file.close();
}

// Save vector<vector<float>> result to .npy file
void save_result(const vector<vector<float>>& result, const string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    string full_path = (results_dir / output_path).string();
    ofstream file(full_path, ios::binary);

    if (!file.is_open()) {
        throw runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    size_t rows = result.size();
    size_t cols = rows > 0 ? result[0].size() : 0;

    ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (" << rows << ", " << cols << "), }";

    string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write float32 data
    for (const auto& row : result) {
        file.write(reinterpret_cast<const char*>(row.data()),
                   row.size() * sizeof(float));
    }
    file.close();
}

int main(int argc, char* argv[]) {
    if (argc < 2) {
        cerr << "Usage: " << argv[0] << " <input_file>" << endl;
        return 1;
    }

    string input_file = argv[1];
    auto start_time = chrono::high_resolution_clock::now();

    try {
        {% if has_preprocess %}
        // Step 1: Preprocessing
        cout << "Running preprocessing..." << endl;
        auto pre_result = preprocess(input_file);
        {% endif %}

        {% if has_inference %}
        // Step 2: Inference (stub)
        cout << "Running inference..." << endl;
        {% if has_preprocess %}
        auto inf_result = inference(pre_result);
        {% else %}
        auto inf_result = inference(input_file);
        {% endif %}
        {% endif %}

        {% if has_postprocess %}
        // Step 3: Postprocessing
        cout << "Running postprocessing..." << endl;
        {% if has_inference %}
        auto final_result = postprocess(inf_result);
        {% elif has_preprocess %}
        auto final_result = postprocess(pre_result);
        {% else %}
        auto final_result = postprocess(input_file);
        {% endif %}
        {% endif %}

        auto end_time = chrono::high_resolution_clock::now();
        auto duration = chrono::duration_cast<chrono::milliseconds>(
            end_time - start_time
        );

        cout << "Pipeline completed successfully" << endl;
        cout << "Total time: " << duration.count() << " ms" << endl;

        // Save result for validation
        {% if has_postprocess %}
        {% if function_name %}
        save_result(final_result, "{{ function_name }}_cpp.npy");
        {% else %}
        save_result(final_result, "pipeline_cpp.npy");
        {% endif %}
        {% elif has_inference %}
        {% if function_name %}
        save_result(inf_result, "{{ function_name }}_cpp.npy");
        {% else %}
        save_result(inf_result, "pipeline_cpp.npy");
        {% endif %}
        {% elif has_preprocess %}
        {% if function_name %}
        save_result(pre_result, "{{ function_name }}_cpp.npy");
        {% else %}
        save_result(pre_result, "pipeline_cpp.npy");
        {% endif %}
        {% endif %}

    } catch (const exception& e) {
        cerr << "Error: " << e.what() << endl;
        return 1;
    }

    return 0;
}
