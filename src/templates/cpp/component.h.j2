// Auto-generated {{ component_name }} component header
// Generated by Python-to-C++ Porting Agent

#ifndef {{ component_name|upper }}_H
#define {{ component_name|upper }}_H

#include <string>
#include <vector>
#include <iostream>
#include <cmath>
#include <algorithm>
#include "img_common.h"

{% for header in headers %}
#include {{ header }}
{% endfor %}

using namespace std;

// Component-specific inline functions (only functions used by this component)
namespace img {
{% set impl_injected = [] %}
{% for op in pipeline.operations %}
{% set mapping = operation_mappings.get(op.id) %}
{% if mapping and mapping.inline_impl and mapping.inline_impl not in impl_injected %}
{% set implementation = implementations.get(mapping.inline_impl) %}
{% if implementation %}
{{ implementation }}
{% set _ = impl_injected.append(mapping.inline_impl) %}
{% endif %}
{% endif %}
{% endfor %}
}  // namespace img

{% macro generate_operations(declared_vars, final_vars) %}
{% for op in pipeline.operations %}
    // {{ op.id }}: {{ op.op_type.value }}
{% if op.op_type.value == 'function_call' %}
{% set mapping = operation_mappings.get(op.id) %}
{% set cpp_func = mapping.cpp_func if mapping else op.function %}
{% set cpp_lib = mapping.cpp_lib if mapping else 'img' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.args|join(', ') }});
{% else %}
    auto {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.args|join(', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'method_call' %}
{% set mapping = operation_mappings.get(op.id) %}
{% set cpp_func = mapping.cpp_func if mapping else op.function %}
{% set cpp_lib = mapping.cpp_lib if mapping else 'img' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% else %}
    auto {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'arithmetic' %}
{% if op.output in declared_vars %}
    {# Variable redeclaration with potential type change - use unique name #}
    auto {{ op.output }}_final = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = final_vars.append(op.output) %}
{% else %}
    auto {{ op.output }} = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'assignment' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ op.args[0] }};
{% else %}
    auto {{ op.output }} = {{ op.args[0] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% endif %}
{% endfor %}
{% endmacro %}

{% if component_name == 'preprocess' %}
inline auto {{ component_name }}(const std::string& {{ pipeline.inputs[0].name }}) {
{% else %}
template<typename T>
inline auto {{ component_name }}(const T& {{ pipeline.inputs[0].name }}) {
{% endif %}
{% set declared_vars = [] %}
{% set final_vars = [] %}
{{ generate_operations(declared_vars, final_vars) }}

{% if pipeline.outputs|length == 1 %}
{% set output_name = pipeline.outputs[0].name %}
{% if output_name in final_vars %}
    return {{ output_name }}_final;
{% else %}
    return {{ output_name }};
{% endif %}
{% else %}
    return std::make_tuple({% for output in pipeline.outputs %}{% if output.name in final_vars %}{{ output.name }}_final{% else %}{{ output.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
{% endif %}
}

#endif // {{ component_name|upper }}_H
