// Auto-generated C++ code from Python preprocessing pipeline
// Generated by Python-to-C++ Porting Agent
// Project: {{ project_name }}

#include <iostream>
#include <string>
#include <vector>
#include <cmath>
#include <algorithm>
#include <filesystem>
#include <fstream>
#include <sstream>

namespace fs = std::filesystem;

// STB Image (header-only library for JPEG/PNG support)
#define STBI_STATIC
#define STB_IMAGE_STATIC
#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

// Inline img namespace (header-free implementation)
namespace img {
    // Image data structure
    struct Image {
        std::vector<uint8_t> data;
        int height, width, channels;

        Image() : height(0), width(0), channels(0) {}
        Image(int h, int w, int c) : height(h), width(w), channels(c) {
            data.resize(h * w * c, 0);
        }

        uint8_t& at(int y, int x, int c) {
            return data[(y * width + x) * channels + c];
        }

        const uint8_t& at(int y, int x, int c) const {
            return data[(y * width + x) * channels + c];
        }
    };

    // Float image for processing
    struct ImageF {
        std::vector<float> data;
        int height, width, channels;

        ImageF() : height(0), width(0), channels(0) {}
        ImageF(int h, int w, int c) : height(h), width(w), channels(c) {
            data.resize(h * w * c, 0.0f);
        }
        ImageF(const Image& img) : height(img.height), width(img.width), channels(img.channels) {
            data.resize(img.data.size());
            for (size_t i = 0; i < img.data.size(); ++i) {
                data[i] = static_cast<float>(img.data[i]);
            }
        }

        float& at(int y, int x, int c) {
            return data[(y * width + x) * channels + c];
        }

        Image to_uint8() const {
            Image result(height, width, channels);
            for (size_t i = 0; i < data.size(); ++i) {
                float val = std::clamp(data[i], 0.0f, 255.0f);
                result.data[i] = static_cast<uint8_t>(val + 0.5f);
            }
            return result;
        }
    };

    // Inline function implementations (only functions used by this pipeline)
{% set impl_injected = [] %}
{% for impl_name in all_implementations %}
{% if impl_name not in impl_injected %}
{% set implementation = implementations.get(impl_name) %}
{% if implementation %}
    {{ implementation }}
{% set _ = impl_injected.append(impl_name) %}
{% endif %}
{% endif %}
{% endfor %}

    // Arithmetic operators for Image types
    inline ImageF operator/(const Image& img, float scalar) {
        ImageF result(img);
        for (auto& val : result.data) {
            val /= scalar;
        }
        return result;
    }

    inline ImageF operator/(const ImageF& img, float scalar) {
        ImageF result = img;
        for (auto& val : result.data) {
            val /= scalar;
        }
        return result;
    }

    inline ImageF reshape(const ImageF& img, int new_height, int new_width) {
        int total_elements = img.height * img.width * img.channels;
        int expected_elements = new_height * new_width;

        if (total_elements != expected_elements) {
            throw std::runtime_error("Cannot reshape: element count mismatch");
        }

        ImageF result(new_height, new_width, 1);
        result.data = img.data;
        return result;
    }
}  // namespace img

{% for pipeline_data in pipelines %}
{% set pipeline = pipeline_data.pipeline %}
{% set operation_mappings = pipeline_data.operation_mappings %}
/**
 * {{ pipeline.name }}
 *
 * Auto-generated function equivalent to Python preprocessing pipeline.
 *
{% for input in pipeline.inputs %}
 * @param {{ input.name }} {{ input.type_hint }}
{% endfor %}
{% for output in pipeline.outputs %}
 * @return {{ output.type_hint }}
{% endfor %}
 */
{% if pipeline.outputs|length == 1 %}
auto {{ pipeline.name }}(
{%- for input in pipeline.inputs -%}
{%- if loop.index0 > 0 %}, {% endif %}const {{ input.type_hint.base_type|cpp_type }}& {{ input.name }}
{%- endfor -%}
) {
{% else %}
std::tuple<{% for output in pipeline.outputs %}{{ output.type_hint.base_type|cpp_type }}{% if not loop.last %}, {% endif %}{% endfor %}> {{ pipeline.name }}(
{%- for input in pipeline.inputs -%}
{%- if loop.index0 > 0 %}, {% endif %}const {{ input.type_hint.base_type|cpp_type }}& {{ input.name }}
{%- endfor -%}
) {
{% endif %}

    // Operations
{% set declared_vars = [] %}
{% set final_vars = [] %}
{% for op in pipeline.operations %}
    // {{ op.id }}: {{ op.op_type.value }}
{% if op.id in llm_generated_code %}
    // LLM-generated code
    {{ llm_generated_code[op.id] }}
{% elif op.op_type.value == 'function_call' %}
{% set mapping = operation_mappings.get(op.id) %}
{% if mapping and mapping.statements %}
    {# N:M mapping - multiple C++ statements for one Python call #}
{% for stmt in mapping.statements %}
    {{ stmt.replace('{output}', op.output).replace('{input}', op.args|join(', ')) }}
{% endfor %}
{% set _ = declared_vars.append(op.output) %}
{% elif mapping and mapping.custom_template %}
    {# Custom template mapping #}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ mapping.custom_template }};
{% else %}
    auto {{ op.output }} = {{ mapping.custom_template }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% else %}
    {# Standard 1:1 function mapping #}
{% set cpp_func = mapping.cpp_func if mapping else op.function %}
{% set cpp_lib = mapping.cpp_lib if mapping else 'img' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.args|join(', ') }});
{% else %}
    auto {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.args|join(', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% endif %}
{% elif op.op_type.value == 'method_call' %}
{% set mapping = operation_mappings.get(op.id) %}
{% if mapping and mapping.statements %}
    {# N:M mapping - multiple C++ statements for one Python call #}
{% for stmt in mapping.statements %}
    {{ stmt.replace('{output}', op.output).replace('{input}', op.source_object) }}
{% endfor %}
{% set _ = declared_vars.append(op.output) %}
{% elif mapping and mapping.custom_template %}
    {# Custom template mapping #}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ mapping.custom_template }};
{% else %}
    auto {{ op.output }} = {{ mapping.custom_template }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% else %}
    {# Standard 1:1 method mapping #}
{% set cpp_func = mapping.cpp_func if mapping else op.function %}
{% set cpp_lib = mapping.cpp_lib if mapping else 'img' %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% else %}
    auto {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ op.source_object }}{% if op.args %}, {{ op.args|join(', ') }}{% endif %});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% endif %}
{% elif op.op_type.value == 'arithmetic' %}
{% if op.output in declared_vars %}
    {# Variable redeclaration with potential type change - use unique name #}
    auto {{ op.output }}_final = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = final_vars.append(op.output) %}
{% else %}
    auto {{ op.output }} = {{ op.operands[0] }} {{ op.operator }} {{ op.operands[1] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'assignment' %}
{% set source_var = op.args[0] + '_final' if op.args[0] in final_vars else op.args[0] %}
{% if op.output in declared_vars %}
    {{ op.output }} = {{ source_var }};
{% else %}
    auto {{ op.output }} = {{ source_var }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'conditional' %}
    // Conditional: if-else
    if ({{ op.condition }}) {
{% for branch_op in op.true_branch %}
        // {{ branch_op.id }}: {{ branch_op.op_type.value }}
        // (nested operation - simplified rendering)
{% endfor %}
    }
{% if op.false_branch %}
    else {
{% for branch_op in op.false_branch %}
        // {{ branch_op.id }}: {{ branch_op.op_type.value }}
        // (nested operation - simplified rendering)
{% endfor %}
    }
{% endif %}
{% elif op.op_type.value == 'loop' %}
    // Loop: {% if op.loop_var %}for{% else %}while{% endif %}
{% if op.loop_var %}
    for (auto {{ op.loop_var }} : {{ op.iterable }}) {
{% else %}
    while ({{ op.iterable }}) {
{% endif %}
{% for loop_op in op.loop_body %}
        // {{ loop_op.id }}: {{ loop_op.op_type.value }}
        // (nested operation - simplified rendering)
{% endfor %}
    }
{% endif %}

{% endfor %}

    // Return
{% if pipeline.outputs|length == 1 %}
{% set output_name = pipeline.outputs[0].name %}
{% if output_name in final_vars %}
    return {{ output_name }}_final;
{% else %}
    return {{ output_name }};
{% endif %}
{% else %}
    return std::make_tuple({% for output in pipeline.outputs %}{% if output.name in final_vars %}{{ output.name }}_final{% else %}{{ output.name }}{% endif %}{% if not loop.last %}, {% endif %}{% endfor %});
{% endif %}
}

{% endfor %}

// Helper function to save img::ImageF results for validation
void save_result(const img::ImageF& result, const std::string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    std::string full_path = (results_dir / output_path).string();
    std::ofstream file(full_path, std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    std::ostringstream header;
    header << "{'descr': '<f4', 'fortran_order': False, 'shape': (";
    header << result.height << ", " << result.width;
    if (result.channels > 1) {
        header << ", " << result.channels;
    }
    header << "), }";

    std::string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += std::string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write data
    file.write(reinterpret_cast<const char*>(result.data.data()),
               result.data.size() * sizeof(float));
    file.close();
}

// Helper function to save int results for validation
void save_result(int result, const std::string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    std::string full_path = (results_dir / output_path).string();
    std::ofstream file(full_path, std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("Failed to open output file: " + full_path);
    }

    // Write numpy .npy format header
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    std::ostringstream header;
    header << "{'descr': '<i4', 'fortran_order': False, 'shape': (), }";

    std::string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += std::string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write data
    file.write(reinterpret_cast<const char*>(&result), sizeof(int));
    file.close();
}

// Helper function to save tuple results for validation (as structured array)
template<typename T1, typename T2>
void save_result(const std::tuple<T1, T2>& result, const std::string& output_path) {
    fs::path results_dir = "results";
    if (!fs::exists(results_dir)) {
        fs::create_directory(results_dir);
    }

    std::string full_path = (results_dir / output_path).string();
    std::ofstream file(full_path, std::ios::binary);

    if (!file.is_open()) {
        throw std::runtime_error("Failed to open output file: " + full_path);
    }

    // Extract values
    auto val1 = std::get<0>(result);
    auto val2 = std::get<1>(result);

    // Determine dtype strings
    std::string dtype1 = (std::is_same<T1, int>::value) ? "i4" : "f8";
    std::string dtype2 = (std::is_same<T2, double>::value || std::is_same<T2, float>::value) ? "f8" : "i4";

    // Write numpy .npy format header for structured array
    file.write("\x93NUMPY", 6);
    char version[2] = {1, 0};
    file.write(version, 2);

    std::ostringstream header;
    header << "{'descr': [('f0', '<" << dtype1 << "'), ('f1', '<" << dtype2 << "')], 'fortran_order': False, 'shape': (), }";

    std::string header_str = header.str();
    int padding = 64 - ((10 + header_str.length()) % 64);
    header_str += std::string(padding, ' ') + '\n';

    uint16_t hlen = header_str.length();
    file.write(reinterpret_cast<char*>(&hlen), 2);
    file.write(header_str.c_str(), header_str.length());

    // Write data as structured record
    if (std::is_same<T1, int>::value) {
        int32_t v1 = static_cast<int32_t>(val1);
        file.write(reinterpret_cast<const char*>(&v1), sizeof(int32_t));
    } else {
        double v1 = static_cast<double>(val1);
        file.write(reinterpret_cast<const char*>(&v1), sizeof(double));
    }

    if (std::is_same<T2, double>::value || std::is_same<T2, float>::value) {
        double v2 = static_cast<double>(val2);
        file.write(reinterpret_cast<const char*>(&v2), sizeof(double));
    } else {
        int32_t v2 = static_cast<int32_t>(val2);
        file.write(reinterpret_cast<const char*>(&v2), sizeof(int32_t));
    }

    file.close();
}

int main(int argc, char** argv) {
    if (argc < 2) {
        std::cerr << "Usage: " << argv[0] << " <input_path>" << std::endl;
        std::cerr << "Example: " << argv[0] << " test.jpg" << std::endl;
        return 1;
    }

    try {
        std::string input_path = argv[1];
        std::cout << "Processing image: " << input_path << std::endl;

{% if main_block_operations %}
        // Main block operations (from Python's if __name__ == "__main__")
{% set declared_vars = ['argc', 'argv', 'input_path', 'image_path'] %}
{% set var_mapping = {'image_path': 'input_path'} %}
{% for op in main_block_operations %}
        // {{ op.id }}: {{ op.op_type.value }}
{% if op.op_type.value == 'assignment' %}
        // Simple assignment
{% if op.output in declared_vars %}
        {{ op.output }} = {{ op.args[0] }};
{% else %}
        auto {{ op.output }} = {{ op.args[0] }};
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% elif op.op_type.value == 'function_call' %}
{% set mapping = main_block_mappings.get(op.id) %}
{% if mapping %}
{% set cpp_func = mapping.cpp_func %}
{% set cpp_lib = mapping.cpp_lib if mapping.cpp_lib else 'img' %}
{% set mapped_args = [] %}
{% for arg in op.args %}
{% set mapped_arg = var_mapping.get(arg, arg) %}
{% set _ = mapped_args.append(mapped_arg) %}
{% endfor %}
{% if op.output %}
{% if op.output in declared_vars %}
        {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ mapped_args|join(', ') }});
{% else %}
        auto {{ op.output }} = {{ cpp_lib }}::{{ cpp_func }}({{ mapped_args|join(', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}
{% else %}
        {{ cpp_lib }}::{{ cpp_func }}({{ mapped_args|join(', ') }});
{% endif %}
{% else %}
        // Unmapped: {{ op.function }}
{% set mapped_args = [] %}
{% for arg in op.args %}
{% set mapped_arg = var_mapping.get(arg, arg) %}
{% set _ = mapped_args.append(mapped_arg) %}
{% endfor %}
{% if op.output %}
{% if op.output in declared_vars %}
        {{ op.output }} = {{ op.function }}({{ mapped_args|join(', ') }});
{% else %}
        auto {{ op.output }} = {{ op.function }}({{ mapped_args|join(', ') }});
{% set _ = declared_vars.append(op.output) %}
{% endif %}

        // Print result info (matching Python output)
        std::cout << "{{ op.function }}: shape=("
                  << {{ op.output }}.height << ", " << {{ op.output }}.width;
        if ({{ op.output }}.channels > 1) {
            std::cout << ", " << {{ op.output }}.channels;
        }
        std::cout << "), dtype=float32" << std::endl;
        save_result({{ op.output }}, "{{ op.function }}_cpp.npy");
{% endif %}
{% endif %}
{% endif %}
{% endfor %}
{% else %}
{% for pipeline_data in pipelines %}
{% set pipeline = pipeline_data.pipeline %}
{% if not main_functions or pipeline.name in main_functions %}
        // Test {{ pipeline.name }}
        {
            auto result = {{ pipeline.name }}(input_path);
            save_result(result, "{{ pipeline.name }}_cpp.npy");

            // Print result info (matching Python output)
            std::cout << "{{ pipeline.name }}: shape=("
                      << result.height << ", " << result.width;
            if (result.channels > 1) {
                std::cout << ", " << result.channels;
            }
            std::cout << "), dtype=float32" << std::endl;
        }
{% endif %}
{% endfor %}
{% endif %}

        return 0;
    } catch (const std::exception& e) {
        std::cerr << "Error: " << e.what() << std::endl;
        return 1;
    }
}
